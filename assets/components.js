document.addEventListener("DOMContentLoaded", function() {

    // Override native anchor link behavior
    function smoothScroll(event) {
        event.preventDefault();
        const targetId = this.getAttribute('href').substring(1);
        const targetElement = document.getElementById(targetId);
        if (targetElement) {
            const buffer = window.innerWidth <= 719 ? 56 : 72;
            window.scrollTo({
                top: targetElement.offsetTop - buffer,
                behavior: 'smooth'
            });
        }
    }
    // Attach smoothScroll function to all anchor links
    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener('click', smoothScroll);
    });
	
	// Append section theme to parent div (automatically generated by Shopify at page render)
  	// Facilitates sibling targeting to fix spacing on adjacent same-theme sections
  	var sections = document.querySelectorAll('#site-main section[class*="theme--"]');
  	sections.forEach(function(section) {
    	var parentDiv = section.closest('.shopify-section');
      	var themeClass = Array.from(section.classList).find(cls => cls.startsWith('theme--')).replace('theme--', 'section-theme--');
      	if (themeClass) {
          	parentDiv.classList.add(themeClass);
      	}
  	});

	// Accordion Component
    const accordions = document.querySelectorAll(".accordion");
    // Open accordion
    const openAccordion = (item) => {
        const content = item.querySelector(".item__content");
        item.classList.add("state--active");
        content.style.maxHeight = content.scrollHeight + "px";
    };
    // Close accordion
    const closeAccordion = (item) => {
        const content = item.querySelector(".item__content");
        item.classList.remove("state--active");
        content.style.maxHeight = null;
    };
    // Open/close active items
    accordions.forEach((accordion) => {
        const items = accordion.querySelectorAll(".item");
        // Open first item in each accordion
        if (items.length > 0) {
            openAccordion(items[0]);
        }
        items.forEach((item) => {
            const heading = item.querySelector(".item__heading");
            const content = item.querySelector(".item__content");
            heading.onclick = () => {
                if (item.classList.contains("state--active")) {
                    closeAccordion(item);
                } else {
                    items.forEach((otherItem) => {
                        if (otherItem !== item) {
                            closeAccordion(otherItem);
                        }
                    });
                    openAccordion(item);
                }
            };
        });
    });

    // Manage quantity selector fields
    function bindQuantitySelectors() {
    const quantitySelectors = document.querySelectorAll('[data-quantity-selector]');

    quantitySelectors.forEach(selector => {
        // Prevent double-binding if this runs again (AJAX cart updates, section reloads, etc.)
        if (selector.dataset.qtyBound === '1') return;
        selector.dataset.qtyBound = '1';

        const minusButton = selector.querySelector('[data-quantity-minus]');
        const plusButton  = selector.querySelector('[data-quantity-plus]');
        const input       = selector.querySelector('[data-quantity-input]');
        const minusWrapper = selector.querySelector('[data-button-wrapper-minus]');

        if (!minusButton || !plusButton || !input) return;

        const updateButtonStates = () => {
        const currentValue = parseInt(input.value, 10) || 0;
        const minValue = parseInt(input.min, 10) || 1;
        if (minusWrapper) {
            minusWrapper.classList.toggle(
            'quantity-selector__button-wrapper--disabled',
            currentValue <= minValue
            );
        }
        };

        const changeQuantity = (amount) => {
        const currentValue = parseInt(input.value, 10) || 0;

        // Force step to 1 (ignores any step="2" surprises)
        const step = 1;

        const minValue = parseInt(input.min, 10) || 1;
        const maxValue = input.max ? parseInt(input.max, 10) : null;

        let newValue = currentValue + (amount * step);
        newValue = Math.max(newValue, minValue);
        if (maxValue !== null && !Number.isNaN(maxValue)) newValue = Math.min(newValue, maxValue);

        // If the value is already the same, don't fire change again
        if (String(input.value) === String(newValue)) return;

        input.value = newValue;
        updateButtonStates();

        // Dispatch a change event so theme cart logic updates
        input.dispatchEvent(new Event('change', { bubbles: true }));
        };

        // Prevent form submit / duplicate handlers
        minusButton.addEventListener('click', (e) => { e.preventDefault(); e.stopPropagation(); changeQuantity(-1); });
        plusButton.addEventListener('click',  (e) => { e.preventDefault(); e.stopPropagation(); changeQuantity(1);  });

        input.addEventListener('change', updateButtonStates);
        updateButtonStates();
    });
    }

    // Run once on page load
    bindQuantitySelectors();



});