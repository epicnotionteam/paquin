document.addEventListener("DOMContentLoaded", function() {

    // Override native anchor link behavior
    function smoothScroll(event) {
        event.preventDefault();
        const targetId = this.getAttribute('href').substring(1);
        const targetElement = document.getElementById(targetId);
        if (targetElement) {
            const buffer = window.innerWidth <= 719 ? 56 : 72;
            window.scrollTo({
                top: targetElement.offsetTop - buffer,
                behavior: 'smooth'
            });
        }
    }
    // Attach smoothScroll function to all anchor links
    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener('click', smoothScroll);
    });
	
	// Append section theme to parent div (automatically generated by Shopify at page render)
  	// Facilitates sibling targeting to fix spacing on adjacent same-theme sections
  	var sections = document.querySelectorAll('#site-main section[class*="theme--"]');
  	sections.forEach(function(section) {
    	var parentDiv = section.closest('.shopify-section');
      	var themeClass = Array.from(section.classList).find(cls => cls.startsWith('theme--')).replace('theme--', 'section-theme--');
      	if (themeClass) {
          	parentDiv.classList.add(themeClass);
      	}
  	});

	// Accordion Component
    const accordions = document.querySelectorAll(".accordion");
    // Open accordion
    const openAccordion = (item) => {
        const content = item.querySelector(".item__content");
        item.classList.add("state--active");
        content.style.maxHeight = content.scrollHeight + "px";
    };
    // Close accordion
    const closeAccordion = (item) => {
        const content = item.querySelector(".item__content");
        item.classList.remove("state--active");
        content.style.maxHeight = null;
    };
    // Open/close active items
    accordions.forEach((accordion) => {
        const items = accordion.querySelectorAll(".item");
        // Open first item in each accordion
        if (items.length > 0) {
            openAccordion(items[0]);
        }
        items.forEach((item) => {
            const heading = item.querySelector(".item__heading");
            const content = item.querySelector(".item__content");
            heading.onclick = () => {
                if (item.classList.contains("state--active")) {
                    closeAccordion(item);
                } else {
                    items.forEach((otherItem) => {
                        if (otherItem !== item) {
                            closeAccordion(otherItem);
                        }
                    });
                    openAccordion(item);
                }
            };
        });
    });
    
        // Manage quantity selector fields
    const quantitySelectors = document.querySelectorAll('[data-quantity-selector]');

    quantitySelectors.forEach((selector) => {
    const minusButton = selector.querySelector('[data-quantity-minus]');
    const plusButton  = selector.querySelector('[data-quantity-plus]');
    const input       = selector.querySelector('[data-quantity-input]');
    const minusWrapper = selector.querySelector('[data-button-wrapper-minus]');

    if (!minusButton || !plusButton || !input) return;

    // IMPORTANT: prevent double-fire (touch/pointer + click)
    let lastActionAt = 0;

    const updateButtonStates = () => {
        const currentValue = parseInt(input.value, 10) || 0;
        const minValue = parseInt(input.min, 10) || 1;
        if (minusWrapper) {
        minusWrapper.classList.toggle(
            'quantity-selector__button-wrapper--disabled',
            currentValue <= minValue
        );
        }
    };

    const changeQuantity = (delta) => {
        const currentValue = parseInt(input.value, 10) || 0;
        const minValue = parseInt(input.min, 10) || 1;
        const maxValue = input.max ? parseInt(input.max, 10) : null;

        let newValue = currentValue + delta; // step assumed 1
        newValue = Math.max(newValue, minValue);
        if (Number.isFinite(maxValue)) newValue = Math.min(newValue, maxValue);

        input.value = newValue;
        updateButtonStates();

        // Let your theme/cart system react to the change
        input.dispatchEvent(new Event('change', { bubbles: true }));
    };

    const handlePress = (delta, e) => {
        const now = Date.now();
        if (now - lastActionAt < 350) return; // blocks the second (synthetic) event
        lastActionAt = now;

        e.preventDefault();
        e.stopPropagation();
        e.stopImmediatePropagation();

        changeQuantity(delta);
    };

    // Use pointerup (covers mouse + touch). Capture phase to intercept early.
    plusButton.addEventListener('pointerup', (e) => handlePress(1, e), true);
    minusButton.addEventListener('pointerup', (e) => handlePress(-1, e), true);

    // Also intercept click so theme delegated click handlers donâ€™t run after pointerup.
    plusButton.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        e.stopImmediatePropagation();
    }, true);

    minusButton.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        e.stopImmediatePropagation();
    }, true);

    input.addEventListener('change', updateButtonStates);
    updateButtonStates();
    });
});